/*
 * Copyright 2020 Nicolo John Davis
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

import { Component } from "./types";

// The Schema object contains the specifications of various
// objects in a particular game.  It does not change in
// value through the course of the game.  It is
// generated by the Editor and interpreted by the Renderer
// in order to generate the graphics on the frontend.

export interface Schema {
  templates: {
    [id: string]: Template;
  };

  objects: {
    [id: string]: SchemaEntry;
  };
}

export namespace Style {
  export interface Geometry {
    width: number;
    height: number;
  }

  export type PartID = string;

  export interface Part {
    type: "box" | "circle";
    id: PartID;
    x: number;
    y: number;
    width: number;
    height: number;
    fill: string;
    stroke: string;
  }

  export type Parts = {
    [id: string]: Style.Part;
  };
}

export interface Template {
  // CARD / SNAP_POINT etc.
  type: Component;

  // width / height of the component.
  geometry: Style.Geometry;

  // Any shapes that need to be rendered inside the template.
  // These are created using the Boardgame Lab editor.
  parts?: Style.Parts;

  // The order in which these parts have to be rendered.
  partOrder?: Style.PartID[];

  // Any placeholders that are meant to be filled in by
  // components that derive from this template.
  placeholders?: {};
}

export interface SchemaEntry {
  templateID: string;
  data?: KeyValue<any>;
  opts?: KeyValue<any>;
  template: {
    placeholders?: {};
  };
}

export interface KeyValue<T> {
  [key: string]: T;
}
